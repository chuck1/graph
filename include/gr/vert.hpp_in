{{ include_block_open }}

#include <memory>
#include <set>
#include <vector>

#include <gr/decl.hpp> // gr/decl.hpp_in
#include <gr/iterator/edge_vert.hpp> // gr/iterator/iterator.hpp.in

{{ namespace_open }}

class vert: public std::enable_shared_from_this<vert>
{
public:
	friend class gr::iterator::edge_graph;

	vert(GRAPH_S);
	virtual ~vert();

	bool			enabled() const;

	GRAPH_S			get_graph();

	/*
	std::vector<S_Edge>	get_edges();
	S_Node			get_other(graph::S_Edge e);
	SET_Node		get_adjacent_verts();
	VEC_PAIR		get_adjacent();
	*/

	gr::iterator::edge_vert	edge_begin();
	gr::iterator::edge_vert	edge_end();
	gr::iterator::edge_vert	edge_erase(gr::iterator::edge_vert &);

	unsigned int		edge_size();

	void			edge_erase_disconnected();

	void			add_edge(gr::EDGE_S);

      	void			edge_erase_util(gr::VERT_S & v0, gr::VERT_S & v1);

	virtual bool		operator==(vert const &) = 0;
	virtual bool		operator!=(vert const &) = 0;
	virtual bool		operator<(vert const &) = 0;

	virtual std::string	dot();
	virtual std::string	name();

	// data
	bool			_M_enabled;

	// for ditance algorithm
	struct {
		double		_M_distance;
	} dist;

	// for bridge-finding algorithm
	struct {
		int		_M_disc;
		int		_M_low;
		bool		_M_visited;
		VERT_W		_M_parent;
	} bridge;

	// for marking components
	struct {
		bool		_M_visited;
		int		_M_c;
	} comp;

	struct {
		bool		_M_visited;
	} dfs;

// private

	GRAPH_W			_M_graph;
//private:	
	gr::container::EDGE_S	_M_edges;
public:
	LAYER_W			_M_layer;
};

{{ namespace_close }}

{{ include_block_close }}



