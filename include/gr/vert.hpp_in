{{ include_block_open }}

#include <memory>
#include <set>
#include <vector>

#include <eigen3/Eigen/Core>

#include <gr/decl.hpp> // gr/decl.hpp_in
#include <gr/iterator/edge_vert.hpp> // gr/iterator/iterator.hpp.in

{{ namespace_open }}

class vert_dot
{
public:
	vert_dot():
		p(0,0),
		f(0,0),
		pos(""),
		shape("oval")
	{}
	Eigen::Vector2f		p;
	Eigen::Vector2f		f;
	std::string	pos;
	std::string	shape;
};

class vert: public std::enable_shared_from_this<vert>
{
public:
	friend class gr::iterator::edge_graph;

	vert(GRAPH_S);
	virtual ~vert();
	virtual gr::VERT_S	copy(GRAPH_S) const;
	bool			enabled() const;
	GRAPH_S			get_graph() const;
	/*
	std::vector<S_Edge>	get_edges();
	S_Node			get_other(graph::S_Edge e);
	SET_Node		get_adjacent_verts();
	VEC_PAIR		get_adjacent();
	*/

	gr::iterator::edge_vert	edge_begin();
	gr::iterator::edge_vert	edge_end();
	gr::iterator::edge_vert	edge_erase(gr::iterator::edge_vert &);

	unsigned int		edge_size();

	void			edge_erase_disconnected();

	void			add_edge(gr::EDGE_S);

      	void			edge_erase_util(gr::VERT_S & v0, gr::VERT_S & v1);

	virtual bool		operator==(vert const &);
	virtual bool		operator!=(vert const &);
	virtual bool		operator<(vert const &);

	virtual std::string	dot();
	virtual std::string	name();

	// data
	//bool			_M_enabled;

	vert_dot		_M_dot;

	// for ditance algorithm
	struct {
		double		_M_distance;
	} dist;

	// for bridge-finding algorithm
	struct {
		int		_M_disc;
		int		_M_low;
		bool		_M_visited;
		VERT_W		_M_parent;
	} bridge;
	struct {
		int		i;
		float		a1;
		float		a2;
	} tree_arrange1;
	struct {
		int		i;
		float		a1;
		float		a2;
	} tree_arrange2;

	// for marking components
	struct {
		bool		_M_visited;
		int		_M_c;
	} comp;

	struct {
		bool		_M_visited;
	} dfs;

	struct {
		int		counter;
	} algo;

// private

	GRAPH_W			_M_graph;
//private:	
	gr::container::EDGE_S	_M_edges;
public:
	LAYER_W			_M_layer;
};

{{ namespace_close }}

{{ include_block_close }}



