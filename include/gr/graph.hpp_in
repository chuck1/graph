{{ include_block_open }}

#include <memory>
#include <set>
#include <vector>
#include <deque>

#include <gr/decl.hpp> // gr/decl.hpp_in
#include <gr/iterator/vert_comp.hpp> // gr/iterator/iterator.hpp.in
#include <gr/iterator/vert_graph.hpp> // gr/iterator/vert_graph.hpp.in
#include <gr/iterator/vert_graph_all.hpp> // gr/iterator/vert_graph_all.hpp.in
#include <gr/container/vert.hpp> // gr/container/vert.hpp_in

{{ namespace_open }}

class less_queue_edge
{
public:
	bool operator()(QUEUE_EDGE const & c0, QUEUE_EDGE const & c1);
};

class ftor_dfs
{
public:
	virtual void	operator()(
		gr::VERT_S const & v1,
		std::deque<gr::EDGE_S> & stack) = 0;
};

class ftor_dfs_cycles: public ftor_dfs
{
public:
	virtual void	operator()(
		gr::VERT_S const & v1,
		std::deque<gr::EDGE_S> & stack);

	SET_QUEUE_EDGE		_M_cycles;
};

class ftor_dfs_paths: public ftor_dfs
{
public:
	virtual void	operator()(
		gr::VERT_S const & v1,
		std::deque<gr::EDGE_S> & stack);

	SET_QUEUE_EDGE		_M_paths;
};

class graph:
	public std::enable_shared_from_this<graph>
{
public:
	//Graph(Graph const & g);
	
	void				add_edge(VERT_S v0, VERT_S v1);
	void				add_edge(EDGE_S e);

	void				edge_enable();
	//void				vert_enable();

	/** vert functions */

	gr::iterator::vert_graph	iter(gr::VERT_S v);

	gr::iterator::vert_graph	vert_find(gr::VERT_S v);
	gr::iterator::vert_graph	vert_erase(gr::iterator::vert_graph &);
	void				vert_erase_layer(unsigned int l);
	
	gr::LAYER_S			create_layer(bool);

	gr::iterator::vert_graph_all	vert_begin_all(VERT_FUNC);
	gr::iterator::vert_graph_all	vert_end_all(VERT_FUNC);
	gr::iterator::vert_graph_all	vert_begin_all();
	gr::iterator::vert_graph_all	vert_end_all();
	gr::iterator::vert_graph	vert_begin();
	gr::iterator::vert_graph	vert_end();
	
	unsigned int			vert_size();

	gr::iterator::vert_comp		comp_vert_begin(int);
	gr::iterator::vert_comp		comp_vert_end(int);


	/** edge functions */

	gr::iterator::edge_graph	edge_begin();
	gr::iterator::edge_graph	edge_end();

	void				edge_erase();

	void				edge_erase_util(VERT_S &, VERT_S &);
	void				edge_erase(VERT_S &, VERT_S &);

	gr::iterator::edge_graph	edge_erase(gr::iterator::edge_graph);

	/** algorithms */

	void				distance_util(gr::VERT_S);
	void				distance(gr::VERT_S const &);

	void				bridges_sub(VERT_S const & n, int & t, std::vector<gr::edge> & ret);
	std::vector<gr::edge>		bridges();


	void				depth_first_search(
			gr::VERT_S const & v,
			ftor_dfs *);
	void				depth_first_search_util(
			gr::VERT_S const & v,
			std::deque<gr::EDGE_S> & stack,
			ftor_dfs *);

	SET_QUEUE_EDGE			cycles();
	SET_QUEUE_EDGE			paths();

	/*
	 * mark each vertex with an index representing the component to which it belongs
	 * a component is a subgraph that is disconnected from the rest of the graph
	 */
	int				components();
	void				components_util(VERT_S const & n, int c);
	void				component(int c);

	void				dot(std::string filename, gr::VERT_S const & v);
	void				dot(std::string filename);
	/**
	 * automatic file name
	 */
	void				dot();
	
	void				layer_move(unsigned int, unsigned int);
	
	void				for_each_leaf(std::function<void(gr::VERT_S const &, gr::EDGE_S const &)> func);

	std::vector<gr::LAYER_S>	_M_layers;
	
	gr::container::vert		_M_verts;
};

{{ namespace_close }}

{{ include_block_close }}

