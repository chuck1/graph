{{ include_block_open }}

#include <memory>
#include <set>
#include <vector>
#include <deque>

#include <logs/logger.hpp> // logs/logger.hpp_in

#include <gr/decl.hpp> // gr/decl.hpp_in
#include <gr/algo/ftor_dfs.hpp> // gr/algo/cycle.hpp_in
#include <gr/algo/cycle.hpp> // gr/algo/cycle.hpp_in
#include <gr/iterator/vert_comp.hpp> // gr/iterator/iterator.hpp.in
#include <gr/iterator/vert_graph.hpp> // gr/iterator/vert_graph.hpp.in
#include <gr/iterator/vert_graph_all.hpp> // gr/iterator/vert_graph_all.hpp.in
#include <gr/container/vert.hpp> // gr/container/vert.hpp_in

{{ namespace_open }}

class graph: public std::enable_shared_from_this<graph>, public logs::logger<graph, {{ logs_mode }}, {{ logs_level }}>
{
public:
	typedef logs::logger<graph, {{ logs_mode }}, {{ logs_level }}> LOGGER;
	//Graph(Graph const & g);

	graph();	
	GRAPH_S				copy();

	void				add_edge(VERT_S v0, VERT_S v1);
	void				add_edge(EDGE_S e);

	void				edge_enable();
	//void				vert_enable();

	/** vert functions */

	gr::iterator::vert_graph	iter(gr::VERT_S v);

	gr::iterator::vert_graph	vert_find(gr::VERT_S v);
	gr::iterator::vert_graph	vert_erase(gr::iterator::vert_graph &);
	void				vert_erase_layer(unsigned int l);
	
	gr::LAYER_S			create_layer(bool);

	gr::iterator::vert_graph_all	vert_begin_all(VERT_FUNC);
	gr::iterator::vert_graph_all	vert_end_all(VERT_FUNC);
	gr::iterator::vert_graph_all	vert_begin_all();
	gr::iterator::vert_graph_all	vert_end_all();
	gr::iterator::vert_graph	vert_begin();
	gr::iterator::vert_graph	vert_end();
	
	unsigned int			vert_size();

	gr::iterator::vert_comp		comp_vert_begin(int);
	gr::iterator::vert_comp		comp_vert_end(int);


	/** edge functions */

	gr::iterator::edge_graph	edge_begin();
	gr::iterator::edge_graph	edge_end();

	void				edge_erase();

	void				edge_erase_util(VERT_S &, VERT_S &);
	void				edge_erase(VERT_S &, VERT_S &);

	gr::iterator::edge_graph	edge_erase(gr::iterator::edge_graph);

	/** algorithms */

	void				distance_util(gr::VERT_S);
	void				distance(gr::VERT_S const &);

	void				bridges_sub(VERT_S const & n, int & t, std::vector<gr::edge> & ret);
	std::vector<gr::edge>		bridges();


	void				depth_first_search(
			gr::VERT_S const & v,
			algo::ftor_dfs *);
	void				depth_first_search_util(
			gr::VERT_S const & v,
			algo::stack & stack,
			algo::ftor_dfs *);

	algo::SET_CYCLE			cycles();
	algo::SET_CYCLE			cycles(gr::VERT_S const &);
	algo::SET_QUEUE_EDGE		paths();

	/*
	 * mark each vertex with an index representing the component to which it belongs
	 * a component is a subgraph that is disconnected from the rest of the graph
	 */
	int				components();
	void				components_util(VERT_S const & n, int c);
	void				component(int c);

	virtual void			dot_sub0(std::ostream & of);
	virtual void			dot_sub1(std::ostream & of);
	void				dot(std::string filename, gr::VERT_S const & v);
	void				dot(std::string filename);
	/**
	 * automatic file name
	 */
	void				dot();
	virtual std::string		dot_edge_symbol();
	
	/**
	 * simplify according to the following
	 *
	 *  - remove verticies that are adjacent to exactly one edge
	 */
	void				simplify();

	void				layer_move(unsigned int, unsigned int);
	
	void				for_each_leaf(std::function<void(gr::VERT_S const &, gr::EDGE_S const &)> func);

	std::vector<gr::LAYER_S>	_M_layers;
	
	gr::container::vert		_M_verts;

	struct {
		GRAPH_S			graph;
	} _M_algo;
	struct {
	} _M_dot;
};
class digraph: public graph
{
public:
	virtual void			dot_sub0(std::ostream & of);
	virtual std::string		dot_edge_symbol();
};

{{ namespace_close }}

{{ include_block_close }}

